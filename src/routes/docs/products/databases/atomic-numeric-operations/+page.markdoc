---
layout: article
title: Atomic numeric operations
description: Safely increment and decrement numeric fields without race conditions. Perfect for counters, quotas, inventory, and usage metrics in high-concurrency applications.
---

Atomic Numeric Operations allow you to safely increase or decrease numeric fields without fetching the full document. This eliminates race conditions and reduces bandwidth usage when updating any numeric values that need to be modified atomically, such as counters, scores, balances, and other fast-moving numeric data.

## How atomic operations work

Instead of the traditional read-modify-write pattern, atomic numeric operations send only the delta value to the server. The server applies the change atomically under concurrency control and returns the new value.

**Traditional approach:**
1. Fetch document → `{ likes: 42 }`
2. Update client-side → `likes: 43`
3. Write back → `{ likes: 43 }`

**Atomic approach:**
1. Send delta → `{ likes: +1 }`
2. Server applies atomically → `likes: 43`

## When to use atomic operations

Atomic numeric operations work well for:

- **Social features**: Likes, follows, comment counts
- **Usage metering**: API credits, storage quotas, request limits
- **Game state**: Scores, lives, currency, experience points
- **E-commerce**: Stock counts, inventory levels
- **Workflow tracking**: Retry counts, progress indicators
- **Rate limiting**: Request counters, usage tracking

## Perform atomic operations

Use the `updateDocument` method with delta values to perform atomic numeric operations. The server will apply these changes atomically under concurrency control.

### Increment a field

{% multicode %}
```client-web
import { Client, Databases } from "appwrite";

const client = new Client()
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
    .setProject('<PROJECT_ID>');

const databases = new Databases(client);

const promise = databases.updateDocument(
    '<DATABASE_ID>',
    '<COLLECTION_ID>',
    '<DOCUMENT_ID>',
    {
        likes: '+1'
    }
);

promise.then(function (response) {
    console.log(response);
}, function (error) {
    console.log(error);
});
```
```client-flutter
import 'package:appwrite/appwrite.dart';

void main() async {
    final client = Client()
        .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
        .setProject('<PROJECT_ID>');

    final databases = Databases(client);

    try {
        final document = await databases.updateDocument(
            databaseId: '<DATABASE_ID>',
            collectionId: '<COLLECTION_ID>',
            documentId: '<DOCUMENT_ID>',
            data: {
                'likes': '+1'
            }
        );
        print(document);
    } on AppwriteException catch(e) {
        print(e);
    }
}
```
```client-apple
import Appwrite
import AppwriteModels

func main() async throws {
    let client = Client()
        .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
        .setProject("<PROJECT_ID>")

    let databases = Databases(client)

    do {
        let document = try await databases.updateDocument(
            databaseId: "<DATABASE_ID>",
            collectionId: "<COLLECTION_ID>",
            documentId: "<DOCUMENT_ID>",
            data: [
                "likes": "+1"
            ]
        )
        print(document)
    } catch {
        print(error.localizedDescription)
    }
}
```
```client-android-kotlin
import io.appwrite.Client
import io.appwrite.services.Databases

suspend fun main() {
    val client = Client(applicationContext)
        .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
        .setProject("<PROJECT_ID>")

    val databases = Databases(client)

    try {
        val document = databases.updateDocument(
            databaseId = "<DATABASE_ID>",
            collectionId = "<COLLECTION_ID>",
            documentId = "<DOCUMENT_ID>",
            data = mapOf("likes" to "+1")
        )
        println(document)
    } catch (e: AppwriteException) {
        Log.e("Appwrite", "Error: " + e.message)
    }
}
```
```server-nodejs
const sdk = require('node-appwrite');

const client = new sdk.Client()
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
    .setProject('<PROJECT_ID>')
    .setKey('<API_KEY>');

const databases = new sdk.Databases(client);

const result = await databases.updateDocument(
    '<DATABASE_ID>',
    '<COLLECTION_ID>',
    '<DOCUMENT_ID>',
    {
        likes: '+1'
    }
);
```
```server-python
from appwrite.client import Client
from appwrite.services.databases import Databases

client = Client()
client.set_endpoint('https://<REGION>.cloud.appwrite.io/v1')
client.set_project('<PROJECT_ID>')
client.set_key('<API_KEY>')

databases = Databases(client)

result = databases.update_document(
    database_id = '<DATABASE_ID>',
    collection_id = '<COLLECTION_ID>',
    document_id = '<DOCUMENT_ID>',
    data = {
        'likes': '+1'
    }
)
```
```graphql
mutation {
    databasesUpdateDocument(
        databaseId: "<DATABASE_ID>",
        collectionId: "<COLLECTION_ID>",
        documentId: "<DOCUMENT_ID>",
        data: "{\"likes\": \"+1\"}"
    ) {
        _id
        _collectionId
        _databaseId
        _createdAt
        _updatedAt
        _permissions
        data
    }
}
```
{% /multicode %}

### Decrement a field

Use negative values to decrease numeric fields:

{% multicode %}
```client-web
const promise = databases.updateDocument(
    '<DATABASE_ID>',
    '<COLLECTION_ID>',
    '<DOCUMENT_ID>',
    {
        credits: '-5'  // Decrease credits by 5
    }
);
```
```client-flutter
final document = await databases.updateDocument(
    databaseId: '<DATABASE_ID>',
    collectionId: '<COLLECTION_ID>',
    documentId: '<DOCUMENT_ID>',
    data: {
        'credits': '-5'  // Decrease credits by 5
    }
);
```
```client-apple
let document = try await databases.updateDocument(
    databaseId: "<DATABASE_ID>",
    collectionId: "<COLLECTION_ID>",
    documentId: "<DOCUMENT_ID>",
    data: [
        "credits": "-5"  // Decrease credits by 5
    ]
)
```
```client-android-kotlin
val document = databases.updateDocument(
    databaseId = "<DATABASE_ID>",
    collectionId = "<COLLECTION_ID>",
    documentId = "<DOCUMENT_ID>",
    data = mapOf("credits" to "-5")  // Decrease credits by 5
)
```
```server-nodejs
const result = await databases.updateDocument(
    '<DATABASE_ID>',
    '<COLLECTION_ID>',
    '<DOCUMENT_ID>',
    {
        credits: '-5'  // Decrease credits by 5
    }
);
```
```server-python
result = databases.update_document(
    database_id = '<DATABASE_ID>',
    collection_id = '<COLLECTION_ID>',
    document_id = '<DOCUMENT_ID>',
    data = {
        'credits': '-5'  // Decrease credits by 5
    }
)
```
```graphql
mutation {
    databasesUpdateDocument(
        databaseId: "<DATABASE_ID>",
        collectionId: "<COLLECTION_ID>",
        documentId: "<DOCUMENT_ID>",
        data: "{\"credits\": \"-5\"}"
    ) {
        _id
        _collectionId
        _databaseId
        _createdAt
        _updatedAt
        _permissions
        data
    }
}
```
{% /multicode %}

### Update multiple fields at once

You can update multiple numeric fields in a single operation:

{% multicode %}
```client-web
const promise = databases.updateDocument(
    '<DATABASE_ID>',
    '<COLLECTION_ID>',
    '<DOCUMENT_ID>',
    {
        likes: '+1',
        views: '+1',
        shares: '+2'
    }
);
```
```client-flutter
final document = await databases.updateDocument(
    databaseId: '<DATABASE_ID>',
    collectionId: '<COLLECTION_ID>',
    documentId: '<DOCUMENT_ID>',
    data: {
        'likes': '+1',
        'views': '+1',
        'shares': '+2'
    }
);
```
```client-apple
let document = try await databases.updateDocument(
    databaseId: "<DATABASE_ID>",
    collectionId: "<COLLECTION_ID>",
    documentId: "<DOCUMENT_ID>",
    data: [
        "likes": "+1",
        "views": "+1",
        "shares": "+2"
    ]
)
```
```client-android-kotlin
val document = databases.updateDocument(
    databaseId = "<DATABASE_ID>",
    collectionId = "<COLLECTION_ID>",
    documentId = "<DOCUMENT_ID>",
    data = mapOf(
        "likes" to "+1",
        "views" to "+1",
        "shares" to "+2"
    )
)
```
```server-nodejs
const result = await databases.updateDocument(
    '<DATABASE_ID>',
    '<COLLECTION_ID>',
    '<DOCUMENT_ID>',
    {
        likes: '+1',
        views: '+1',
        shares: '+2'
    }
);
```
```server-python
result = databases.update_document(
    database_id = '<DATABASE_ID>',
    collection_id = '<COLLECTION_ID>',
    document_id = '<DOCUMENT_ID>',
    data = {
        'likes': '+1',
        'views': '+1',
        'shares': '+2'
    }
)
```
```graphql
mutation {
    databasesUpdateDocument(
        databaseId: "<DATABASE_ID>",
        collectionId: "<COLLECTION_ID>",
        documentId: "<DOCUMENT_ID>",
        data: "{\"likes\": \"+1\", \"views\": \"+1\", \"shares\": \"+2\"}"
    ) {
        _id
        _collectionId
        _databaseId
        _createdAt
        _updatedAt
        _permissions
        data
    }
}
```
{% /multicode %}

## Set constraints and bounds

You can set minimum and maximum bounds for numeric fields to prevent invalid values:

{% info title="Collection configuration required" %}
Constraints must be configured at the collection level when defining attributes.
[Learn more about collection attributes](/docs/products/databases/collections#attributes)
{% /info %}

### Example with constraints

If your collection has a `credits` field with a minimum of 0 and maximum of 1000:

{% multicode %}
```client-web
// This will succeed if credits >= 5
const promise = databases.updateDocument(
    '<DATABASE_ID>',
    '<COLLECTION_ID>',
    '<DOCUMENT_ID>',
    {
        credits: '-5'
    }
);

// This will throw an error if credits would go below 0
const promise = databases.updateDocument(
    '<DATABASE_ID>',
    '<COLLECTION_ID>',
    '<DOCUMENT_ID>',
    {
        credits: '-1000'  // Error: Value would exceed minimum
    }
);
```
```client-flutter
// This will succeed if credits >= 5
final document = await databases.updateDocument(
    databaseId: '<DATABASE_ID>',
    collectionId: '<COLLECTION_ID>',
    documentId: '<DOCUMENT_ID>',
    data: {
        'credits': '-5'
    }
);

// This will throw an error if credits would go below 0
try {
    final document = await databases.updateDocument(
        databaseId: '<DATABASE_ID>',
        collectionId: '<COLLECTION_ID>',
        documentId: '<DOCUMENT_ID>',
        data: {
            'credits': '-1000'  // Error: Value would exceed minimum
        }
    );
} on AppwriteException catch(e) {
    print('Constraint violation: ${e.message}');
}
```
{% /multicode %}

## Follow best practices

### Use for high-concurrency scenarios

Atomic numeric operations are most beneficial when multiple users or processes might update the same numeric field simultaneously.

### Mix atomic and regular updates

You can mix atomic operations with regular field updates in the same request:

{% multicode %}
```client-web
const promise = databases.updateDocument(
    '<DATABASE_ID>',
    '<COLLECTION_ID>',
    '<DOCUMENT_ID>',
    {
        likes: '+1',           // Atomic increment
        lastLikedBy: userId,   // Regular update
        lastLikedAt: new Date().toISOString()
    }
);
```
```client-flutter
final document = await databases.updateDocument(
    databaseId: '<DATABASE_ID>',
    collectionId: '<COLLECTION_ID>',
    documentId: '<DOCUMENT_ID>',
    data: {
        'likes': '+1',           // Atomic increment
        'lastLikedBy': userId,   // Regular update
        'lastLikedAt': DateTime.now().toIso8601String()
    }
);
```
{% /multicode %}


## Explore related features

- [Bulk operations](/docs/products/databases/bulk-operations) - Update multiple documents at once
- [Permissions](/docs/products/databases/permissions) - Control access to documents
- [Queries](/docs/products/databases/queries) - Find documents to update
- [Relationships](/docs/products/databases/relationships) - Update related documents