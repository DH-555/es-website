---
layout: article
title: Atomic numeric operations
description: Safely increment and decrement numeric fields without race conditions. Perfect for counters, quotas, inventory, and usage metrics in high-concurrency applications.
---

Atomic numeric operations allow you to safely increase or decrease numeric fields without fetching the full row. This eliminates race conditions and reduces bandwidth usage when updating any numeric values that need to be modified atomically, such as counters, scores, balances, and other fast-moving numeric data.

# How atomic operations work {% #how-atomic-operations-work %}

Instead of the traditional read-modify-write pattern, atomic numeric operations use dedicated methods to modify values directly on the server. The server applies the change atomically under concurrency control and returns the new value.

**Traditional approach:**
1. Fetch row → `{ likes: 42 }`
2. Update client-side → `likes: 43`
3. Write back → `{ likes: 43 }`

**Atomic approach:**
1. Call `incrementRowAttribute()` with the attribute name and the value to increment by
2. Server applies atomically → `likes: 43`

# When to use atomic operations {% #when-to-use-atomic-operations %}

Atomic numeric operations work well for:

- **Social features**: Likes, follows, comment counts
- **Usage metering**: API credits, storage quotas, request limits
- **Game state**: Scores, lives, currency, experience points
- **E-commerce**: Stock counts, inventory levels
- **Workflow tracking**: Retry counts, progress indicators
- **Rate limiting**: Request counters, usage tracking

# Perform atomic operations {% #perform-atomic-operations %}

Use the `incrementRowAttribute` and `decrementRowAttribute` methods to perform atomic numeric operations. The server will apply these changes atomically under concurrency control.

## Increment a field {% #increment-field %}

{% multicode %}
```client-web
import { Client, Grids } from "appwrite";

const client = new Client()
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1') // Your API Endpoint
    .setProject('<YOUR_PROJECT_ID>'); // Your project ID

const grids = new Grids(client);

const result = await grids.incrementRowAttribute(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    '<ROW_ID>',
    'likes', // attribute
    1 // value
);
```
```client-flutter
import 'package:appwrite/appwrite.dart';

final client = Client()
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
    .setProject('<PROJECT_ID>');

final grids = Grids(client);

final row = await grids.incrementRowAttribute(
    databaseId: '<DATABASE_ID>',
    tableId: '<TABLE_ID>',
    rowId: '<ROW_ID>',
    attribute: 'likes',
    value: 1
);
```
```client-apple
import Appwrite
import AppwriteModels

let client = Client()
    .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
    .setProject("<PROJECT_ID>")

let grids = Grids(client)

let row = try await grids.incrementRowAttribute(
    databaseId: "<DATABASE_ID>",
    tableId: "<TABLE_ID>",
    rowId: "<ROW_ID>",
    attribute: "likes",
    value: 1
)
```
```client-android-kotlin
import io.appwrite.Client
import io.appwrite.services.Databases

val client = Client(applicationContext)
    .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
    .setProject("<PROJECT_ID>")

val grids = Grids(client)

val row = grids.incrementRowAttribute(
    databaseId = "<DATABASE_ID>",
    tableId = "<TABLE_ID>",
    rowId = "<ROW_ID>",
    attribute = "likes",
    value = 1
)
```
```server-nodejs
const sdk = require('node-appwrite');

const client = new sdk.Client()
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1') // Your API Endpoint
    .setProject('<PROJECT_ID>') // Your project ID
    .setKey('<API_KEY>'); // Your secret API key

const grids = new sdk.Grids(client);

const result = await grids.incrementRowAttribute(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    '<ROW_ID>',
    'likes', // attribute
    1 // value
);
```
```server-python
from appwrite.client import Client
from appwrite.services.grids import Grids

client = Client()
client.set_endpoint('https://<REGION>.cloud.appwrite.io/v1') # Your API Endpoint
client.set_project('<PROJECT_ID>') # Your project ID
client.set_key('<API_KEY>') # Your secret API key

grids = Grids(client)

result = grids.increment_row_attribute(
    database_id = '<DATABASE_ID>',
    table_id = '<TABLE_ID>',
    row_id = '<ROW_ID>',
    attribute = 'likes', # attribute
    value = 1 # value
)
```
```graphql
mutation {
    databasesIncrementRowAttribute(
        databaseId: "<DATABASE_ID>",
        tableId: "<TABLE_ID>",
        rowId: "<ROW_ID>",
        attribute: "likes",
        value: 1
    ) {
        _id
        _tableId
        _databaseId
        _createdAt
        _updatedAt
        _permissions
        data
    }
}
```
{% /multicode %}

## Decrement a field {% #decrement-field %}

Use the `decrementRowAttribute` method to decrease numeric fields:

{% multicode %}
```client-web
import { Client, Grids } from "appwrite";

const client = new Client()
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1') // Your API Endpoint
    .setProject('<YOUR_PROJECT_ID>'); // Your project ID

const grids = new Grids(client);

const result = await grids.decrementRowAttribute(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    '<ROW_ID>',
    'credits', // attribute
    5 // value
);
```
```client-flutter
import 'package:appwrite/appwrite.dart';

final client = Client()
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
    .setProject('<PROJECT_ID>');

final grids = Grids(client);

final row = await grids.decrementRowAttribute(
    databaseId: '<DATABASE_ID>',
    tableId: '<TABLE_ID>',
    rowId: '<ROW_ID>',
    attribute: 'credits',
    value: 5
);
```
```client-apple
import Appwrite
import AppwriteModels

let client = Client()
    .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
    .setProject("<PROJECT_ID>")

let grids = Grids(client)

let row = try await grids.decrementRowAttribute(
    databaseId: "<DATABASE_ID>",
    tableId: "<TABLE_ID>",
    rowId: "<ROW_ID>",
    attribute: "credits",
    value: 5
)
```
```client-android-kotlin
import io.appwrite.Client
import io.appwrite.services.Databases

val client = Client(applicationContext)
    .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
    .setProject("<PROJECT_ID>")

val grids = Grids(client)

val row = grids.decrementRowAttribute(
    databaseId = "<DATABASE_ID>",
    tableId = "<TABLE_ID>",
    rowId = "<ROW_ID>",
    attribute = "credits",
    value = 5
)
```
```server-nodejs
const sdk = require('node-appwrite');

const client = new sdk.Client()
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1') // Your API Endpoint
    .setProject('<PROJECT_ID>') // Your project ID
    .setKey('<API_KEY>'); // Your secret API key

const grids = new sdk.Grids(client);

const result = await grids.decrementRowAttribute(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    '<ROW_ID>',
    'credits', // attribute
    5 // value
);
```
```server-python
from appwrite.client import Client
from appwrite.services.grids import Grids

client = Client()
client.set_endpoint('https://<REGION>.cloud.appwrite.io/v1') # Your API Endpoint
client.set_project('<PROJECT_ID>') # Your project ID
client.set_key('<API_KEY>') # Your secret API key

grids = Grids(client)

result = grids.decrement_row_attribute(
    database_id = '<DATABASE_ID>',
    table_id = '<TABLE_ID>',
    row_id = '<ROW_ID>',
    attribute = 'credits', # attribute
    value = 5 # value
)
```
```graphql
mutation {
    databasesDecrementRowAttribute(
        databaseId: "<DATABASE_ID>",
        tableId: "<TABLE_ID>",
        rowId: "<ROW_ID>",
        attribute: "credits",
        value: 5
    ) {
        _id
        _tableId
        _databaseId
        _createdAt
        _updatedAt
        _permissions
        data
    }
}
```
{% /multicode %}

# Set constraints and bounds {% #set-constraints-and-bounds %}

You can set minimum and maximum bounds for individual operations to prevent invalid values. Use the optional `min` and `max` parameters to ensure the final value stays within acceptable limits:

## Example with constraints {% #example-with-constraints %}

{% multicode %}
```client-web
// Increment with maximum constraint
const result = await grids.incrementRowAttribute(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    '<ROW_ID>',
    'credits', // attribute
    100, // value
    1000 // max (optional)
);

// Decrement with minimum constraint
const result2 = await grids.decrementRowAttribute(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    '<ROW_ID>',
    'credits', // attribute
    50, // value
    0 // min (optional)
);
```
```client-flutter
// Increment with maximum constraint
final row = await grids.incrementRowAttribute(
    databaseId: '<DATABASE_ID>',
    tableId: '<TABLE_ID>',
    rowId: '<ROW_ID>',
    attribute: 'credits',
    value: 100,
    max: 1000
);

// Decrement with minimum constraint
final row2 = await grids.decrementRowAttribute(
    databaseId: '<DATABASE_ID>',
    tableId: '<TABLE_ID>',
    rowId: '<ROW_ID>',
    attribute: 'credits',
    value: 50,
    min: 0
);
```
```client-apple
// Increment with maximum constraint
let row = try await grids.incrementRowAttribute(
    databaseId: "<DATABASE_ID>",
    tableId: "<TABLE_ID>",
    rowId: "<ROW_ID>",
    attribute: "credits",
    value: 100,
    max: 1000
)

// Decrement with minimum constraint
let row2 = try await grids.decrementRowAttribute(
    databaseId: "<DATABASE_ID>",
    tableId: "<TABLE_ID>",
    rowId: "<ROW_ID>",
    attribute: "credits",
    value: 50,
    min: 0
)
```
```client-android-kotlin
// Increment with maximum constraint
val row = grids.incrementRowAttribute(
    databaseId = "<DATABASE_ID>",
    tableId = "<TABLE_ID>",
    rowId = "<ROW_ID>",
    attribute = "credits",
    value = 100,
    max = 1000
)

// Decrement with minimum constraint
val row2 = grids.decrementRowAttribute(
    databaseId = "<DATABASE_ID>",
    tableId = "<TABLE_ID>",
    rowId = "<ROW_ID>",
    attribute = "credits",
    value = 50,
    min = 0
)
```
```server-nodejs
// Increment with maximum constraint
const result = await grids.incrementRowAttribute(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    '<ROW_ID>',
    'credits', // attribute
    100, // value
    1000 // max (optional)
);

// Decrement with minimum constraint
const result2 = await grids.decrementRowAttribute(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    '<ROW_ID>',
    'credits', // attribute
    50, // value
    0 // min (optional)
);
```
```server-python
# Increment with maximum constraint
result = grids.increment_row_attribute(
    database_id = '<DATABASE_ID>',
    table_id = '<TABLE_ID>',
    row_id = '<ROW_ID>',
    attribute = 'credits', # attribute
    value = 100, # value
    max = 1000 # max (optional)
)

# Decrement with minimum constraint
result2 = grids.decrement_row_attribute(
    database_id = '<DATABASE_ID>',
    table_id = '<TABLE_ID>',
    row_id = '<ROW_ID>',
    attribute = 'credits', # attribute
    value = 50, # value
    min = 0 # min (optional)
)
```
{% /multicode %}

# Follow best practices {% #follow-best-practices %}

## Use for high-concurrency scenarios {% #use-for-high-concurrency-scenarios %}

Atomic numeric operations are most beneficial when multiple users or processes might update the same numeric field simultaneously.

## Combine with regular updates {% #combine-with-regular-updates %}

For complex updates that include both atomic operations and regular field changes, you'll need to use separate API calls:

{% multicode %}
```client-web
// First, increment the likes atomically
const likeResult = await grids.incrementRowAttribute(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    '<ROW_ID>',
    'likes', // attribute
    1 // value
);

// Then, update other fields
const updateResult = await grids.updateRow(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    '<ROW_ID>',
    {
        lastLikedBy: userId,
        lastLikedAt: new Date().toISOString()
    }
);
```
```client-flutter
// First, increment the likes atomically
final likeResult = await grids.incrementRowAttribute(
    databaseId: '<DATABASE_ID>',
    tableId: '<TABLE_ID>',
    rowId: '<ROW_ID>',
    attribute: 'likes',
    value: 1
);

// Then, update other fields
final updateResult = await grids.updateRow(
    databaseId: '<DATABASE_ID>',
    tableId: '<TABLE_ID>',
    rowId: '<ROW_ID>',
    data: {
        'lastLikedBy': userId,
        'lastLikedAt': DateTime.now().toIso8601String()
    }
);
```
```client-apple
// First, increment the likes atomically
let likeResult = try await grids.incrementRowAttribute(
    databaseId: "<DATABASE_ID>",
    tableId: "<TABLE_ID>",
    rowId: "<ROW_ID>",
    attribute: "likes",
    value: 1
)

// Then, update other fields
let updateResult = try await grids.updateRow(
    databaseId: "<DATABASE_ID>",
    tableId: "<TABLE_ID>",
    rowId: "<ROW_ID>",
    data: [
        "lastLikedBy": userId,
        "lastLikedAt": ISO8601DateFormatter().string(from: Date())
    ]
)
```
```client-android-kotlin
// First, increment the likes atomically
val likeResult = grids.incrementRowAttribute(
    databaseId = "<DATABASE_ID>",
    tableId = "<TABLE_ID>",
    rowId = "<ROW_ID>",
    attribute = "likes",
    value = 1
)

// Then, update other fields
val updateResult = grids.updateRow(
    databaseId = "<DATABASE_ID>",
    tableId = "<TABLE_ID>",
    rowId = "<ROW_ID>",
    data = mapOf(
        "lastLikedBy" to userId,
        "lastLikedAt" to Instant.now().toString()
    )
)
```
```server-nodejs
// First, increment the likes atomically
const likeResult = await grids.incrementRowAttribute(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    '<ROW_ID>',
    'likes', // attribute
    1 // value
);

// Then, update other fields
const updateResult = await grids.updateRow(
    '<DATABASE_ID>',
    '<TABLE_ID>',
    '<ROW_ID>',
    {
        lastLikedBy: userId,
        lastLikedAt: new Date().toISOString()
    }
);
```
```server-python
# First, increment the likes atomically
like_result = grids.increment_row_attribute(
    database_id = '<DATABASE_ID>',
    table_id = '<TABLE_ID>',
    row_id = '<ROW_ID>',
    attribute = 'likes', # attribute
    value = 1 # value
)

# Then, update other fields
update_result = grids.update_row(
    database_id = '<DATABASE_ID>',
    table_id = '<TABLE_ID>',
    row_id = '<ROW_ID>',
    data = {
        'lastLikedBy': user_id,
        'lastLikedAt': datetime.now().isoformat()
    }
)
```
{% /multicode %}

## Explore related features

- [Bulk operations](/docs/products/databases/bulk-operations) - Update multiple rows at once
- [Permissions](/docs/products/databases/permissions) - Control access to rows
- [Queries](/docs/products/databases/queries) - Find rows to update
- [Relationships](/docs/products/databases/relationships) - Update related rows