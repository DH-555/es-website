---
layout: article
title: Transactions
description: Stage multiple database operations and commit them atomically. Group changes across databases and tables with ordering, isolation, and conflict detection.
---

Transactions let you stage multiple database operations and apply them together, atomically. Use transactions to keep related changes consistent, even when they span multiple databases and tables.

# How transactions work {% #how-transactions-work %}

1. Call the [createTransaction](#create-a-transaction) method to create a transaction. This will return a transaction model, including its ID.
2. Stage operations by passing the `transactionId` parameter to supported row, bulk, and atomic numeric methods. To stage many at once, use the [createOperations](#create-operations) method.
3. Call the [updateTransaction](#update-transaction) method to commit or roll back.

On commit, Appwrite replays all staged logs in order inside a real database transaction. Staged operations see earlier staged changes (read your own writes). If any affected row changed outside your transaction, the commit fails with a conflict.

{% info title="Scope and limitations" %}
You can stage operations across any database and table within the same transaction. Schema operations (for example, adding or removing columns) are not included in transactions.
{% /info %}

# Create a transaction {% #create-a-transaction %}

Call the `createTransaction` method to begin. It returns a transaction model that includes `$id`. Pass this ID as `transactionId` to subsequent operations.

{% multicode %}
```client-web
import { Client, TablesDB } from 'appwrite';

const client = new Client()
  .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
  .setProject('<PROJECT_ID>');

const tablesDB = new TablesDB(client);

const tx = await tablesDB.createTransaction();
// tx.$id is your transactionId
```
```client-react-native
import { Client, TablesDB } from 'react-native-appwrite';

const client = new Client()
  .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
  .setProject('<PROJECT_ID>');

const tablesDB = new TablesDB(client);

const tx = await tablesDB.createTransaction();
// tx.$id is your transactionId
```
```client-flutter
import 'package:appwrite/appwrite.dart';

final client = Client()
  .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
  .setProject('<PROJECT_ID>');

final tablesDB = TablesDB(client);

final tx = await tablesDB.createTransaction();
// tx.$id is your transactionId
```
```client-apple
import Appwrite

let client = Client()
  .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
  .setProject("<PROJECT_ID>")

let tablesDB = TablesDB(client)

let tx = try await tablesDB.createTransaction()
// tx.$id is your transactionId
```
```client-android-kotlin
import io.appwrite.Client
import io.appwrite.services.TablesDB

val client = Client(applicationContext)
  .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
  .setProject("<PROJECT_ID>")

val tablesDB = TablesDB(client)

val tx = tablesDB.createTransaction()
// tx.$id is your transactionId
```
```client-android-java
import io.appwrite.Client;
import io.appwrite.services.TablesDB;

Client client = new Client()
    .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
    .setProject("<PROJECT_ID>");

TablesDB tablesDB = new TablesDB(client);

// Create a transaction (asynchronous)
tablesDB.createTransaction(new CoroutineCallback<>((tx, error) -> {
  if (error != null) {
    error.printStackTrace();
    return;
  }
  System.out.println(tx);
}));
```
```server-nodejs
const sdk = require('node-appwrite');

const client = new sdk.Client()
  .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
  .setProject('<PROJECT_ID>')
  .setKey('<API_KEY>');

const tablesDB = new sdk.TablesDB(client);

const tx = await tablesDB.createTransaction();
// tx.$id is your transactionId
```
```server-deno
import * as sdk from 'npm:node-appwrite';

const client = new sdk.Client()
  .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
  .setProject('<PROJECT_ID>')
  .setKey('<API_KEY>');

const tablesDB = new sdk.TablesDB(client);

const tx = await tablesDB.createTransaction();
// tx.$id is your transactionId
```
```server-python
from appwrite.client import Client
from appwrite.services.tablesDB import TablesDB

client = Client()
client.set_endpoint('https://<REGION>.cloud.appwrite.io/v1')
client.set_project('<PROJECT_ID>')
client.set_key('<API_KEY>')

tablesDB = TablesDB(client)

tx = tablesDB.create_transaction()
# tx.$id is your transactionId
```
```server-php
<?php

use Appwrite\Client;
use Appwrite\Services\TablesDB;

$client = new Client();

$client
  ->setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
  ->setProject('<PROJECT_ID>')
  ->setKey('<API_KEY>')
;

$tablesDB = new TablesDB($client);

$tx = $tablesDB->createTransaction();
// $tx->\$id is your transactionId
```
```server-ruby
require 'appwrite'

include Appwrite

client = Client.new
  .set_endpoint('https://<REGION>.cloud.appwrite.io/v1')
  .set_project('<PROJECT_ID>')
  .set_key('<API_KEY>')

tablesDB = TablesDB.new(client)

tx = tablesDB.create_transaction
# tx['$id'] is your transactionId
```
```server-dotnet
using Appwrite;
using Appwrite.Services;

var client = new Client()
  .SetEndPoint("https://<REGION>.cloud.appwrite.io/v1")
  .SetProject("<PROJECT_ID>")
  .SetKey("<API_KEY>");

var tablesDB = new TablesDB(client);

var tx = await tablesDB.CreateTransaction();
// tx.$id is your transactionId
```
```server-dart
import 'package:dart_appwrite/dart_appwrite.dart';

void main() async {
  Client client = Client();
  TablesDB tablesDB = TablesDB(client);

  client
    .setEndpoint('https://<REGION>.cloud.appwrite.io/v1')
    .setProject('<PROJECT_ID>')
    .setKey('<API_KEY>');

  final tx = await tablesDB.createTransaction();
  // tx contains the transaction ID
}
```
```server-go
package main

import (
  "log"
  "github.com/appwrite/sdk-for-go/appwrite"
)

func main() {
  client := appwrite.NewClient(
    appwrite.WithEndpoint("https://<REGION>.cloud.appwrite.io/v1"),
    appwrite.WithProject("<PROJECT_ID>"),
    appwrite.WithKey("<API_KEY>"),
  )

  tablesDB := appwrite.NewTablesDB(client)

  tx, err := tablesDB.CreateTransaction()
  if err != nil { log.Fatal(err) }
  _ = tx
}
```
```server-swift
import Appwrite

let client = Client()
  .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
  .setProject("<PROJECT_ID>")
  .setKey("<API_KEY>")

let tablesDB = TablesDB(client)

let tx = try await tablesDB.createTransaction()
// tx.$id is your transactionId
```
```server-kotlin
import io.appwrite.Client
import io.appwrite.services.TablesDB

val client = Client()
  .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
  .setProject("<PROJECT_ID>")
  .setKey("<API_KEY>")

val tablesDB = TablesDB(client)

val tx = tablesDB.createTransaction()
// tx.$id is your transactionId
```
```server-java
import io.appwrite.Client;
import io.appwrite.coroutines.CoroutineCallback;
import io.appwrite.services.TablesDB;

Client client = new Client()
  .setEndpoint("https://<REGION>.cloud.appwrite.io/v1")
  .setProject("<PROJECT_ID>")
  .setKey("<API_KEY>");

TablesDB tablesDB = new TablesDB(client);

tablesDB.createTransaction(new CoroutineCallback<>((result, error) -> {
  if (error != null) {
    error.printStackTrace();
    return;
  }
  System.out.println(result);
}));
```
{% /multicode %}

# Stage operations {% #stage-operations %}

Add the `transactionId` parameter to supported methods to stage them instead of immediately persisting.

When you pass `transactionId`, Appwrite writes the operation to an internal table named `transactionLogs`. The target table is not modified until you commit the transaction.

## Stage single operations {% #stage-single-operations %}

Create, update, upsert, delete, and atomic numeric operations accept `transactionId`.

{% multicode %}
```client-web
// Create inside a transaction
await tablesDB.createRow({
  databaseId: '<DATABASE_ID>',
  tableId: '<TABLE_ID>',
  rowId: '<ROW_ID>',
  data: { name: 'Walter' },
  transactionId: tx.$id
});

// Increment inside a transaction
await tablesDB.incrementRowColumn({
  databaseId: '<DATABASE_ID>',
  tableId: '<TABLE_ID>',
  rowId: '<ROW_ID>',
  column: 'credits',
  value: 1,
  transactionId: tx.$id
});
```
```client-flutter
// Create inside a transaction
await tablesDB.createRow(
  databaseId: '<DATABASE_ID>',
  tableId: '<TABLE_ID>',
  rowId: '<ROW_ID>',
  data: { 'name': 'Walter' },
  transactionId: tx.$id
);

// Increment inside a transaction
await tablesDB.incrementRowColumn(
  databaseId: '<DATABASE_ID>',
  tableId: '<TABLE_ID>',
  rowId: '<ROW_ID>',
  column: 'credits',
  value: 1,
  transactionId: tx.$id
);
```
```client-apple
// Create inside a transaction
let _ = try await tablesDB.createRow(
  databaseId: "<DATABASE_ID>",
  tableId: "<TABLE_ID>",
  rowId: "<ROW_ID>",
  data: ["name": "Walter"],
  transactionId: tx.$id
)

// Increment inside a transaction
let _ = try await tablesDB.incrementRowColumn(
  databaseId: "<DATABASE_ID>",
  tableId: "<TABLE_ID>",
  rowId: "<ROW_ID>",
  column: "credits",
  value: 1,
  transactionId: tx.$id
)
```
```client-android-kotlin
// Create inside a transaction
val _ = tablesDB.createRow(
  databaseId = "<DATABASE_ID>",
  tableId = "<TABLE_ID>",
  rowId = "<ROW_ID>",
  data = mapOf("name" to "Walter"),
  transactionId = tx.$id
)

// Increment inside a transaction
val _2 = tablesDB.incrementRowColumn(
  databaseId = "<DATABASE_ID>",
  tableId = "<TABLE_ID>",
  rowId = "<ROW_ID>",
  column = "credits",
  value = 1,
  transactionId = tx.$id
)
```
```client-react-native
// Create inside a transaction
await tablesDB.createRow({
  databaseId: '<DATABASE_ID>',
  tableId: '<TABLE_ID>',
  rowId: '<ROW_ID>',
  data: { name: 'Walter' },
  transactionId: tx.$id
});

// Increment inside a transaction
await tablesDB.incrementRowColumn({
  databaseId: '<DATABASE_ID>',
  tableId: '<TABLE_ID>',
  rowId: '<ROW_ID>',
  column: 'credits',
  value: 1,
  transactionId: tx.$id
});
```
```server-nodejs
// Update inside a transaction
await tablesDB.updateRow({
  databaseId: '<DATABASE_ID>',
  tableId: '<TABLE_ID>',
  rowId: '<ROW_ID>',
  data: { plan: 'pro' },
  transactionId: tx.$id
});

// Delete inside a transaction
await tablesDB.deleteRow({
  databaseId: '<DATABASE_ID>',
  tableId: '<TABLE_ID>',
  rowId: '<ROW_ID>',
  transactionId: tx.$id
});
```
```server-python
# Upsert inside a transaction
tablesDB.upsert_row(
  database_id = '<DATABASE_ID>',
  table_id = '<TABLE_ID>',
  row_id = '<ROW_ID>',
  data = { 'name': 'Walter' },
  transaction_id = tx['$id']
)

# Decrement inside a transaction
tablesDB.decrement_row_column(
  database_id = '<DATABASE_ID>',
  table_id = '<TABLE_ID>',
  row_id = '<ROW_ID>',
  column = 'credits',
  value = 1,
  transaction_id = tx['$id']
)
```
{% /multicode %}

## Stage many with createOperations {% #create-operations %}

Use the `createOperations` method to stage multiple operations across databases and tables in a single request. Provide an array of operation objects:

```json
[
  {
    "action": "create|update|upsert|increment|decrement|delete|bulkCreate|bulkUpdate|bulkUpsert|bulkDelete",
    "databaseId": "<DATABASE_ID>",
    "tableId|collectionId": "<TABLE_ID|COLLECTION_ID>",
    "rowId|documentId": "<ROW_ID|DOCUMENT_ID>",
    "data": {}
  }
]
```

### Provide data for each action (createOperations) {% #provide-data-for-each-action %}

### Create, update, and upsert {% #create-update-upsert %}
Pass a raw data object.
```json
{ "name": "Walter" }
```

### Increment and decrement {% #increment-decrement %}
Pass a value and optionally `min`/`max` bounds.
```json
{ "value": 1, "min": 0, "max": 1000 }
```

### Bulk create and bulk upsert {% #bulk-create-upsert %}
Pass an array of raw data objects.
```json
[{ "$id": "123", "name": "Walter" }]
```

### Bulk update {% #bulk-update %}
Pass queries and the data to apply.
```json
{ "queries": ["equal(\"status\", [\"draft\"])"], "data": { "status": "published" } }
```

### Bulk delete {% #bulk-delete %}
Pass queries to select rows to delete.
```json
{ "queries": ["equal(\"archived\", [true])"] }
```

{% multicode %}
```server-nodejs
// Stage multiple operations at once
await tablesDB.createOperations({
  transactionId: tx.$id,
  operations: [
    {
      action: 'create',
      databaseId: '<DB_A>',
      tableId: '<TABLE_1>',
      rowId: 'u1',
      data: { name: 'Walter' }
    },
    {
      action: 'increment',
      databaseId: '<DB_B>',
      tableId: '<TABLE_2>',
      rowId: 'u2',
      data: { value: 1, min: 0 }
    }
  ]
});
```
```server-python
tablesDB.create_operations(
  transaction_id = tx['$id'],
  operations = [
    {
      'action': 'upsert',
      'databaseId': '<DB_A>',
      'tableId': '<TABLE_1>',
      'rowId': 'u3',
      'data': { 'name': 'Skyler' }
    },
    {
      'action': 'bulkDelete',
      'databaseId': '<DB_B>',
      'tableId': '<TABLE_2>',
      'data': { 'queries': ["equal(\"status\", [\"archived\"])" ] }
    }
  ]
)
```
{% /multicode %}

# Commit or roll back {% #commit-or-rollback %}

When you are done staging operations, call the `updateTransaction` method to finalize the transaction.

{% multicode %}
```client-web
// Commit
await tablesDB.updateTransaction({ transactionId: tx.$id, commit: true });

// Or roll back
await tablesDB.updateTransaction({ transactionId: tx.$id, rollback: true });
```
```client-flutter
// Commit
await tablesDB.updateTransaction(
  transactionId: tx.$id,
  commit: true
);

// Roll back
await tablesDB.updateTransaction(
  transactionId: tx.$id,
  rollback: true
);
```
```client-apple
// Commit
let _ = try await tablesDB.updateTransaction(
  transactionId: tx.$id,
  commit: true
)

// Roll back
let _ = try await tablesDB.updateTransaction(
  transactionId: tx.$id,
  rollback: true
)
```
```client-android-kotlin
// Commit
val _ = tablesDB.updateTransaction(
  transactionId = tx.$id,
  commit = true
)

// Roll back
val _2 = tablesDB.updateTransaction(
  transactionId = tx.$id,
  rollback = true
)
```
```client-react-native
// Commit
await tablesDB.updateTransaction({ transactionId: tx.$id, commit: true });

// Roll back
await tablesDB.updateTransaction({ transactionId: tx.$id, rollback: true });
```
```server-nodejs
// Commit
await tablesDB.updateTransaction({ transactionId: tx.$id, commit: true });

// Roll back
await tablesDB.updateTransaction({ transactionId: tx.$id, rollback: true });
```
```server-python
# Commit
tablesDB.update_transaction(transaction_id = tx['$id'], commit = True)

# Roll back
tablesDB.update_transaction(transaction_id = tx['$id'], rollback = True)
```
```server-php
// Commit
$tablesDB->updateTransaction(transactionId: $tx['$id'], commit: true);

// Roll back
$tablesDB->updateTransaction(transactionId: $tx['$id'], rollback: true);
```
```server-ruby
# Commit
tablesDB.update_transaction(transaction_id: tx['$id'], commit: true)

# Roll back
tablesDB.update_transaction(transaction_id: tx['$id'], rollback: true)
```
```server-dotnet
// Commit
await tablesDB.UpdateTransaction(
  transactionId: tx.Id,
  commit: true
);

// Roll back
await tablesDB.UpdateTransaction(
  transactionId: tx.Id,
  rollback: true
);
```
```server-dart
// Commit
await tablesDB.updateTransaction(
  transactionId: tx.Id,
  commit: true
);

// Roll back
await tablesDB.updateTransaction(
  transactionId: tx.Id,
  rollback: true
);
```
{% /multicode %}

# Handle conflicts {% #handle-conflicts %}

On commit, Appwrite verifies that rows affected by your transaction haven’t changed externally since they were staged. If a conflicting change is detected, the commit fails with a conflict error. Resolve the conflict (for example, refetch and re-stage) and try again.

{% info title="Best practices" %}
Keep transactions short-lived to reduce the likelihood of conflicts. Stage related updates in the order they must be applied. Prefer `createOperations` when you need to stage many changes across multiple tables.
{% /info %}

{% arrow_link href="/docs/references" %}
Explore the API references
{% /arrow_link %}
